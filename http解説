了解。いま出した WinFormsサーバー（HttpListener） と WPFクライアント（HttpClient + OSプロキシ） の実装について、「どのクラスで何をしているか」「処理の流れ」を噛み砕いて説明します。

⸻

全体像（何が起きているか）
	•	WPFクライアントが固定の JSON 文字列（{"type":"dummy","message":"HELLO"}）を
http://localhost:8080/api/submit に HTTP POST で送る
	•	WinFormsサーバーがその POST を HttpListener で受け取り、受信ボディを読んでから
JSON の応答（{"result":"ok", ...}）を返す

重要ポイント：
	•	OSのプロキシ設定は クライアント（HttpClient）側で使う（サーバー側は受けるだけ）

⸻

サーバー側（WinForms / HttpListener）の解説

どのクラスを使っているか

Form1（WinForms の画面クラス）
	•	WinFormsアプリのメインフォーム（画面）だけど、今回はUIを使わず 「生きている間サーバーを動かす箱」 として使っています。
	•	フォームが表示されたらサーバー開始、閉じたらサーバー停止、というライフサイクル管理を担当します。

HttpListener
	•	Windows の HTTP.sys を使って、HTTP リクエストを待ち受ける標準クラス。
	•	Prefixes.Add("http://localhost:8080/") で 受け付けるURLの“根っこ” を登録します。
	•	Start() で待受開始。
	•	GetContextAsync() で「リクエストが来るまで待って、来たらコンテキスト（リクエスト/レスポンス）を返す」。

HttpListenerContext
	•	1つのHTTPリクエストに対応する入れ物。
	•	ctx.Request（受信した情報）と ctx.Response（返信するための情報）を持ちます。

HttpListenerRequest
	•	リクエスト側の情報：
	•	HttpMethod（GET/POST）
	•	Url.AbsolutePath（/api/submit）
	•	InputStream（POSTボディ）

HttpListenerResponse
	•	レスポンス側の情報：
	•	StatusCode（200, 404, 500）
	•	ContentType（application/json）
	•	OutputStream（返信ボディを書き込むストリーム）

CancellationTokenSource / CancellationToken
	•	サーバー停止時に待受ループを止めるための仕組みです。
	•	StopServer() → _cts.Cancel() で「止まれ」という合図を出せます。

⸻

サーバー側の処理の流れ（コードの順に）

1) 起動時にサーバー開始
	•	OnShown()（フォームが表示された瞬間に呼ばれる）で StartServer() を実行。

StartServer() がやっていること：
	1.	_listener = new HttpListener()
	2.	_listener.Prefixes.Add(Prefix) で http://localhost:8080/ を登録
	3.	_listener.Start() で待受開始
	4.	AcceptLoopAsync() をバックグラウンドで回し始める
（UIスレッドを止めないために Task.Run）

2) リクエストを待ち続けるループ（AcceptLoopAsync）
	•	GetContextAsync() を繰り返し呼びます。
	•	ここは「電話の受信待ち」みたいなイメージです。

止めるときの挙動：
	•	Stop() / Close() が呼ばれると GetContextAsync() が例外で抜けます。
	•	それを catch してループ終了します。

3) 1件受けたら処理を別タスクに投げる（HandleAsync）
	•	AcceptLoopAsync の中で、受け取った ctx を HandleAsync(ctx) に渡して処理。
	•	1件ごとに別タスクにしているので、複数リクエストが来ても待受ループが詰まりにくいです。

HandleAsync がやっていること：
	1.	POST かつ /api/submit かチェック
	2.	OKなら req.InputStream から本文（JSON文字列）を読み取る
	3.	応答用の JSON（result ok 等）を作る
	4.	WriteJsonAsync で res.OutputStream に書き込む
	5.	最後に res.Close()（通信の終了）

4) WriteJsonAsync
	•	返信の共通処理をまとめた関数。
	•	StatusCode / ContentType / ContentLength64 を設定し、UTF-8で書き込みます。
	•	ContentLength64 を正しく設定しているので、クライアントが受信終了を認識できます。

⸻

クライアント側（WPF / HttpClient + OSプロキシ）の解説

どのクラスを使っているか

MainWindow（WPFの画面クラス）
	•	ボタンを押したら送信するだけ。

HttpClient
	•	HTTPリクエストを送るクライアント。
	•	PostAsync(url, content) で POST を送る。

HttpClientHandler
	•	HttpClient の「通信のしかた（プロキシ、証明書、認証など）」を制御するハンドラ。
	•	今回はここで OSプロキシ設定 を反映しています。

WebRequest.GetSystemWebProxy()
	•	「Windowsの（現在ユーザーの）システムプロキシ設定」を返します。
	•	手動設定だけでなく、環境によっては 自動検出/PAC を含めた挙動になります。

IWebProxy / Credentials
	•	GetSystemWebProxy() が返すのは IWebProxy。
	•	systemProxy.Credentials = CredentialCache.DefaultCredentials により、認証プロキシがいても通る可能性が上がります（AD統合のケースなど）。

StringContent
	•	送信する本文（ここでは固定JSON文字列）を application/json として扱うためのクラス。

Dispatcher.InvokeAsync
	•	PostAsync はUIスレッド以外で完了することがあるので、UI操作（MessageBoxなど）をするときにUIスレッドへ戻します。

⸻

クライアント側の処理の流れ

1) HttpClient を 1回だけ作る（Lazy）
private static readonly Lazy<HttpClient> _client = new Lazy<HttpClient>(CreateHttpClient);

	•	目的：毎回 new しない（ソケット枯渇や遅延の原因になるので）
	•	最初に送信するときに CreateHttpClient() が1回だけ実行されます。

2) CreateHttpClient（OSプロキシ設定を反映）
	•	WebRequest.GetSystemWebProxy() で OS のプロキシを取得
	•	認証が必要なプロキシ向けに DefaultCredentials を設定
	•	HttpClientHandler.Proxy = systemProxy、UseProxy = true を設定
	•	その handler で HttpClient を生成

3) ボタン押下で固定JSONをPOST
	•	dummyJson は完全固定
	•	StringContent(dummyJson, UTF8, "application/json") にすることで Content-Type が JSON になる
	•	PostAsync(Endpoint, content) を実行
	•	応答を ReadAsStringAsync で読み捨て（今回は処理しない前提）

⸻

この構成の意図（なぜこう書いているか）
	•	サーバーは UI で操作しない → 起動と同時に待受し、終了時に止めるのが一番シンプル
	•	AcceptLoop と Handle を分ける → 待受を詰まらせず、同時処理にも耐えやすい
	•	HttpClient を使い回す → 実運用で一番ハマる“毎回new問題”を避ける
	•	OSプロキシは HttpClientHandler に設定 → “OS設定に従った通信” を実現するためのポイント

⸻

必要なら次のステップとして、
	•	サーバーを localhost ではなく LANの別PCからも受ける（http://+:8080/）ようにした版
	•	受信した JSON を パース（DataContractJsonSerializer / Newtonsoft.Json） して型で扱う版
	•	タイムアウト／キャンセル／エラーハンドリングをもう少し堅くした版

もそのまま差し替えできる形で出せます。
