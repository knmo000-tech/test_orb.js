// src/export/exportOrbAlignedWithMerges.js

/**
 * orb の表示レイアウトに近い形で .xlsx 出力する
 * - merges(rowspan/colspan) 再現（※今回は rowHeaders の merge を無効化できる）
 * - rowHeaders 省略によるズレを occ + nextFreeCol で解消
 * - numFmt は pivotSpec から決定（Web/Excel を単一定義化）
 *
 * 仕様（この版）:
 * - 上側のヘッダ（colHeaders）はデフォルトで出力しない（includeColHeaders=false）
 * - 左側ヘッダ（rowHeaders）はデフォルトで結合しない（mergeRowHeaders=false）
 *   -> 結合していた範囲(rs×cs)すべてのセルに同じ文字を入れる
 *
 * @param {any} pgridwidget
 * @param {string} fileName
 * @param {object|null} pivotSpec  pivotSpec.js の pivotSpec を渡す（任意）
 * @param {object} opts
 *   - XLSX: xlsx-js-style を直接渡したい場合
 *   - defaultNumFmt: マッチしない場合の既定フォーマット（例 "General" / "#,##0"）
 *   - includeColHeaders: 上側ヘッダを出す（デフォルト false）
 *   - mergeRowHeaders: 左側ヘッダを merge する（デフォルト false）
 */
function exportOrbAlignedWithMerges(
  pgridwidget,
  fileName = "pivot_aligned.xlsx",
  pivotSpec = null,
  opts = {}
) {
  const XLSX = opts.XLSX ?? globalThis.XLSX;
  if (!XLSX) throw new Error("XLSX(xlsx-js-style) が見つかりません。globalThis.XLSX を確認してください。");

  const includeColHeaders = opts.includeColHeaders ?? false; // ★上側ヘッダ不要
  const mergeRowHeaders = opts.mergeRowHeaders ?? false;      // ★左側ヘッダは結合しない
  const defaultNumFmt = opts.defaultNumFmt ?? "General";

  const rowHeaders = pgridwidget?.rows?.headers || [];
  const dataRows = pgridwidget?.dataRows || [];
  const colHeaders = pgridwidget?.columns?.headers || pgridwidget?.cols?.headers || [];

  const bodyRows = Math.max(rowHeaders.length, dataRows.length);
  const colHeaderHeight = includeColHeaders ? colHeaders.length : 0;

  // data列数（右側の値セル数）
  const dataCols = dataRows.reduce((m, r) => Math.max(m, (r || []).length), 0);

  // row header 幅（左側のヘッダ列数）は「hspanの合計の最大」で決める
  const rowHeaderWidth = rowHeaders.reduce((m, r) => {
    const w = (r || []).reduce((s, h) => s + (h?.hspan ? h.hspan(true) : 1), 0);
    return Math.max(m, w);
  }, 0);

  const totalRows = colHeaderHeight + bodyRows;
  const totalCols = rowHeaderWidth + dataCols;

  // ===== PivotSpec 由来の numFmt 引き当て（caption依存を極小化） =====
  const spec = pivotSpec ?? globalThis.pivotSpec ?? null;

  const fmtResolver = (() => {
    if (!spec?.fields) return null;

    const norm = (s) => String(s ?? "").trim();

    // name(ID) -> numFmt
    const byName = new Map();
    // caption -> name(ID)（orbがIDを返してくれない時の保険）
    const captionToName = new Map();

    for (const f of spec.fields) {
      if (!f?.dataSettings) continue; // measureだけ対象
      const id = String(f.name);
      const fmt = f?.excel?.numFmt ?? null;
      byName.set(id, fmt);
      captionToName.set(norm(f.caption), id);
    }

    function extractIdFromHeaderValue(v) {
      if (v == null) return null;

      // number / numeric string ならそれを ID とみなす
      if (typeof v === "number") return String(v);
      if (typeof v === "string") {
        const s = v.trim();
        if (s && /^-?\d+(\.\d+)?$/.test(s)) return String(Number(s));
        if (captionToName.has(norm(s))) return captionToName.get(norm(s));
        return null;
      }

      if (typeof v === "object") {
        const candidates = [
          v.name,
          v.field,
          v.fieldName,
          v.fieldId,
          v.datafield,
          v.dataField,
          v.measure,
          v.measureId,
          v.value,
        ];

        for (const c of candidates) {
          if (typeof c === "number") return String(c);
          if (typeof c === "string") {
            const s = c.trim();
            if (s && /^-?\d+(\.\d+)?$/.test(s)) return String(Number(s));
            if (captionToName.has(norm(s))) return captionToName.get(norm(s));
          }
        }

        if (v.caption != null) {
          const key = norm(v.caption);
          if (captionToName.has(key)) return captionToName.get(key);
        }
      }

      return null;
    }

    // rowHeaders のその行から「どの measure 行か」を推測して numFmt を返す
    function numFmtForRowHeaderRow(rhRow) {
      if (!Array.isArray(rhRow)) return null;

      // 1) まず ID(name) を拾う
      for (const h of rhRow) {
        const id = extractIdFromHeaderValue(h?.value);
        if (!id) continue;
        if (byName.has(id)) return byName.get(id);
      }

      // 2) それでも無理なら caption（保険）
      for (const h of rhRow) {
        const t = norm(toText(h?.value));
        const id = captionToName.get(t);
        if (id && byName.has(id)) return byName.get(id);
      }

      return null;
    }

    return { numFmtForRowHeaderRow };
  })();

  function toText(v) {
    if (v == null) return "";
    if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") return String(v);
    if (typeof v === "object") {
      if ("caption" in v && v.caption != null) return String(v.caption);
      if ("name" in v && v.name != null) return String(v.name);
      if ("value" in v && v.value != null) return String(v.value);
    }
    try {
      return JSON.stringify(v);
    } catch {
      return String(v);
    }
  }

  // --- blue theme（固定） ---
  const BLUE_HEADER_FILL = "FFEAF8FF"; // 薄い水色
  const BLUE_BORDER = "FF9DD4E8";      // 罫線の水色
  const GRID_BORDER = { style: "thin", color: { rgb: BLUE_BORDER } };

  const colHeaderStyle = {
    font: { bold: true },
    alignment: { vertical: "center", horizontal: "center", wrapText: true },
    fill: { patternType: "solid", fgColor: { rgb: BLUE_HEADER_FILL } },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  const rowHeaderStyle = {
    font: { bold: true },
    alignment: { vertical: "center", horizontal: "left", wrapText: true },
    fill: { patternType: "solid", fgColor: { rgb: BLUE_HEADER_FILL } },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  const valueStyle = {
    alignment: { vertical: "center", horizontal: "right" },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  // シート用のグリッド（空で埋める）
  const aoa = Array.from({ length: totalRows }, () => Array.from({ length: totalCols }, () => ""));

  // どこが埋まっているか（rowspan/colspanを扱うため）
  const occ = Array.from({ length: totalRows }, () => Array.from({ length: totalCols }, () => false));

  const merges = [];
  function occupy(r, c, rs, cs, doMerge = true) {
    const rEnd = Math.min(totalRows, r + rs);
    const cEnd = Math.min(totalCols, c + cs);

    for (let rr = r; rr < rEnd; rr++) {
      for (let cc = c; cc < cEnd; cc++) occ[rr][cc] = true;
    }
    if (doMerge && (rs > 1 || cs > 1)) {
      merges.push({ s: { r, c }, e: { r: r + rs - 1, c: c + cs - 1 } });
    }
  }

  function nextFreeCol(r, startC) {
    let c = startC;
    while (c < totalCols && occ[r][c]) c++;
    return c;
  }

  // --- （任意）上側ヘッダ（colHeaders） ---
  if (includeColHeaders) {
    for (let r = 0; r < colHeaderHeight; r++) {
      const headers = colHeaders[r] || [];
      let c = rowHeaderWidth;

      for (const h of headers) {
        c = nextFreeCol(r, c);
        const cs = h?.hspan ? h.hspan(true) : 1;
        const rs = h?.vspan ? h.vspan(true) : 1;

        aoa[r][c] = { v: toText(h?.value), t: "s", s: colHeaderStyle };
        occupy(r, c, rs, cs, true);

        c += cs;
      }
    }
  }

  const RED_FONT = { color: { rgb: "FFFF0000" } }; // 赤
  function applyNegativeRed(style, n) {
    if (typeof n === "number" && n < 0) {
      style.font = { ...(style.font || {}), ...RED_FONT };
    }
    return style;
  }

  // --- 左側ヘッダ（rowHeaders）+ 値（dataRows） ---
  for (let i = 0; i < bodyRows; i++) {
    const sheetRow = colHeaderHeight + i; // colHeaderHeight=0 なら先頭から
    const headers = rowHeaders[i] || [];
    let c = 0;

    for (const h of headers) {
      c = nextFreeCol(sheetRow, c);
      const cs = h?.hspan ? h.hspan(true) : 1;
      const rs = h?.vspan ? h.vspan(true) : 1;
      const text = toText(h?.value);

      if (mergeRowHeaders) {
        // 従来：左上のみ + merge
        aoa[sheetRow][c] = { v: text, t: "s", s: rowHeaderStyle };
        occupy(sheetRow, c, rs, cs, true);
      } else {
        // ★結合しない：結合範囲(rs×cs)すべてに同じ文字を埋める
        for (let rr = sheetRow; rr < sheetRow + rs; rr++) {
          for (let cc = c; cc < c + cs; cc++) {
            // 範囲外ガード
            if (rr < 0 || rr >= totalRows || cc < 0 || cc >= totalCols) continue;
            aoa[rr][cc] = { v: text, t: "s", s: rowHeaderStyle };
          }
        }
        occupy(sheetRow, c, rs, cs, false); // mergeは作らない
      }

      c += cs;
      if (c >= rowHeaderWidth) break;
    }

    // pivotSpec から numFmt を決める（name(ID)優先、ダメならcaption保険）
    const rowNumFmt = (fmtResolver?.numFmtForRowHeaderRow(rowHeaders[i]) ?? null) ?? defaultNumFmt;

    const dr = dataRows[i] || [];
    for (let j = 0; j < dr.length; j++) {
      const v = dr[j]?.value;
      const col = rowHeaderWidth + j;

      if (v === null || v === undefined || v === "") {
        aoa[sheetRow][col] = { v: "", t: "s", s: valueStyle };
        continue;
      }

      const n = Number(v);
      if (!Number.isFinite(n)) {
        aoa[sheetRow][col] = { v: String(v), t: "s", s: valueStyle };
        continue;
      }

      const s = applyNegativeRed({ ...valueStyle, numFmt: rowNumFmt }, n);
      // xlsx-js-style は z が効きやすいので z もセット
      aoa[sheetRow][col] = { v: n, t: "n", z: rowNumFmt, s };
    }
  }

  const ws = XLSX.utils.aoa_to_sheet(aoa);
  ws["!merges"] = merges; // rowHeaders mergeRowHeaders=falseならここには入らない

  // ===== 罫線（格子） + 列幅オート調整 =====
  const GRID_LINE = { style: "thin", color: { rgb: "FF9DD4E8" } };
  const GRID_BORDER_ALL = { top: GRID_LINE, bottom: GRID_LINE, left: GRID_LINE, right: GRID_LINE };

  function applyGridBorders(ws) {
    const ref = ws["!ref"];
    if (!ref) return;

    const range = XLSX.utils.decode_range(ref);
    for (let r = range.s.r; r <= range.e.r; r++) {
      for (let c = range.s.c; c <= range.e.c; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        let cell = ws[addr];
        if (!cell) cell = ws[addr] = { t: "s", v: "" };
        cell.s = cell.s || {};
        cell.s.border = GRID_BORDER_ALL;
      }
    }
  }

  function calcTextWidth(str) {
    const s = String(str ?? "");
    let w = 0;
    for (const ch of s) w += ch.charCodeAt(0) <= 0x7f ? 1 : 2;
    return w;
  }

  function countTrailingCommas(fmt) {
    const m = String(fmt ?? "").match(/,+$/);
    return m ? m[0].length : 0;
  }

  function displayText(cell) {
    if (!cell) return "";
    const v = cell.v;

    if (cell.t === "n") {
      const n0 = Number(v);
      if (!Number.isFinite(n0)) return "";

      const fmt = cell.z || cell.s?.numFmt;

      if (fmt && String(fmt).includes("%")) {
        const decimals = (String(fmt).match(/0\.([0]+)/)?.[1]?.length) ?? 0;
        return `${(n0 * 100).toFixed(decimals)}%`;
      }

      const k = countTrailingCommas(fmt);
      const n = k > 0 ? n0 / Math.pow(1000, k) : n0;

      if (fmt === "#,##0" || (fmt && String(fmt).startsWith("#,##0"))) {
        return new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 }).format(n);
      }

      return String(n);
    }

    return String(v ?? "");
  }

  function autofitColumns(ws, { minWidth = 8, maxWidth = 30, padding = 2 } = {}) {
    const ref = ws["!ref"];
    if (!ref) return;

    const range = XLSX.utils.decode_range(ref);
    const colCount = range.e.c - range.s.c + 1;
    const widths = Array(colCount).fill(minWidth);

    for (let r = range.s.r; r <= range.e.r; r++) {
      for (let c = range.s.c; c <= range.e.c; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        const cell = ws[addr];
        const text = displayText(cell);
        const w = Math.min(maxWidth, Math.max(minWidth, calcTextWidth(text) + padding));
        widths[c - range.s.c] = Math.max(widths[c - range.s.c], w);
      }
    }

    ws["!cols"] = widths.map((wch) => ({ wch }));
  }

  applyGridBorders(ws);
  autofitColumns(ws, { minWidth: 8, maxWidth: 32, padding: 2 });

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Pivot");
  XLSX.writeFile(wb, fileName);
}
