// src/export/exportOrbAlignedWithMerges.js

/**
 * orb の表示レイアウトに近い形で .xlsx 出力する
 * - merges(rowspan/colspan) 再現
 * - rowHeaders 省略によるズレを occ + nextFreeCol で解消
 * - numFmt は pivotSpec から決定（Web/Excel を単一定義化）
 *
 * 重要:
 * - まず pivotSpec.fields[].name（数値/ID）で判定する
 * - orb の header.value に name(ID) が見えない場合のみ caption を“保険”に使う
 *
 * @param {any} pgridwidget
 * @param {string} fileName
 * @param {object|null} pivotSpec  pivotSpec.js の pivotSpec を渡す（任意）
 * @param {object} opts
 *   - XLSX: xlsx-js-style を直接渡したい場合
 *   - defaultNumFmt: マッチしない場合の既定フォーマット（例 "General" / "#,##0"）
 */
function exportOrbAlignedWithMerges(
  pgridwidget,
  fileName = "pivot_aligned.xlsx",
  pivotSpec = null,
  opts = {}
) {
  const XLSX = opts.XLSX ?? globalThis.XLSX;
  if (!XLSX) throw new Error("XLSX(xlsx-js-style) が見つかりません。globalThis.XLSX を確認してください。");

  const rowHeaders = pgridwidget?.rows?.headers || [];
  const dataRows = pgridwidget?.dataRows || [];
  const colHeaders = pgridwidget?.columns?.headers || pgridwidget?.cols?.headers || [];

  const bodyRows = Math.max(rowHeaders.length, dataRows.length);
  const colHeaderHeight = colHeaders.length;

  // data列数（右側の値セル数）
  const dataCols = dataRows.reduce((m, r) => Math.max(m, (r || []).length), 0);

  // row header 幅（左側のヘッダ列数）は「hspanの合計の最大」で決める
  const rowHeaderWidth = rowHeaders.reduce((m, r) => {
    const w = (r || []).reduce((s, h) => s + (h?.hspan ? h.hspan(true) : 1), 0);
    return Math.max(m, w);
  }, 0);

  const totalRows = colHeaderHeight + bodyRows;
  const totalCols = rowHeaderWidth + dataCols;

  // ===== PivotSpec 由来の numFmt 引き当て（caption依存を最小化） =====
  const spec = pivotSpec ?? globalThis.pivotSpec ?? null;
  const defaultNumFmt = opts.defaultNumFmt ?? "General";

  const fmtResolver = (() => {
    if (!spec?.fields) return null;

    const norm = (s) => String(s ?? "").trim();

    // name(ID) -> numFmt
    const byName = new Map();
    // caption -> name(ID)（orbがIDを返してくれない時の保険）
    const captionToName = new Map();

    for (const f of spec.fields) {
      if (!f?.dataSettings) continue; // measureだけ対象
      const id = String(f.name);
      const fmt = f?.excel?.numFmt ?? null;
      byName.set(id, fmt);
      captionToName.set(norm(f.caption), id);
    }

    function extractIdFromHeaderValue(v) {
      if (v == null) return null;

      // number / numeric string ならそれを ID とみなす
      if (typeof v === "number") return String(v);
      if (typeof v === "string") {
        const s = v.trim();
        if (s && /^-?\d+(\.\d+)?$/.test(s)) return String(Number(s));
        // 保険：captionとして一致するならIDへ変換
        if (captionToName.has(norm(s))) return captionToName.get(norm(s));
        return null;
      }

      if (typeof v === "object") {
        // よくありそうなキーを広めに見る
        const candidates = [
          v.name,
          v.field,
          v.fieldName,
          v.fieldId,
          v.datafield,
          v.dataField,
          v.measure,
          v.measureId,
          v.value, // header.value がさらに {value:...} の入れ子の場合も
        ];

        for (const c of candidates) {
          if (typeof c === "number") return String(c);
          if (typeof c === "string") {
            const s = c.trim();
            if (s && /^-?\d+(\.\d+)?$/.test(s)) return String(Number(s));
            if (captionToName.has(norm(s))) return captionToName.get(norm(s));
          }
        }

        // caption が取れれば最後の保険でIDに変換
        if (v.caption != null) {
          const key = norm(v.caption);
          if (captionToName.has(key)) return captionToName.get(key);
        }
      }

      return null;
    }

    // rowHeaders のその行から「どの measure 行か」を推測して numFmt を返す
    function numFmtForRowHeaderRow(rhRow) {
      if (!Array.isArray(rhRow)) return null;

      // 1) まず ID(name) を拾う
      for (const h of rhRow) {
        const id = extractIdFromHeaderValue(h?.value);
        if (!id) continue;
        if (byName.has(id)) return byName.get(id);
      }

      // 2) それでも無理なら、rowHeaders 文字列化して captionToName を探す（保険）
      for (const h of rhRow) {
        const t = toText(h?.value);
        const id = captionToName.get(norm(t));
        if (id && byName.has(id)) return byName.get(id);
      }

      return null;
    }

    return { numFmtForRowHeaderRow };
  })();

  function toText(v) {
    if (v == null) return "";
    if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") return String(v);
    if (typeof v === "object") {
      if ("caption" in v && v.caption != null) return String(v.caption);
      if ("name" in v && v.name != null) return String(v.name);
      if ("value" in v && v.value != null) return String(v.value);
    }
    try {
      return JSON.stringify(v);
    } catch {
      return String(v);
    }
  }

  // --- blue theme（固定） ---
  const BLUE_HEADER_FILL = "FFEAF8FF"; // 薄い水色
  const BLUE_BORDER = "FF9DD4E8"; // 罫線の水色
  const GRID_BORDER = { style: "thin", color: { rgb: BLUE_BORDER } };

  const colHeaderStyle = {
    font: { bold: true },
    alignment: { vertical: "center", horizontal: "center", wrapText: true },
    fill: { patternType: "solid", fgColor: { rgb: BLUE_HEADER_FILL } },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  const rowHeaderStyle = {
    font: { bold: true },
    alignment: { vertical: "center", horizontal: "left", wrapText: true },
    fill: { patternType: "solid", fgColor: { rgb: BLUE_HEADER_FILL } },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  const valueStyle = {
    alignment: { vertical: "center", horizontal: "right" },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  // シート用のグリッド（空で埋める）
  const aoa = Array.from({ length: totalRows }, () => Array.from({ length: totalCols }, () => ""));

  // どこが埋まっているか（rowspan/colspanを扱うため）
  const occ = Array.from({ length: totalRows }, () => Array.from({ length: totalCols }, () => false));

  const merges = [];
  function occupy(r, c, rs, cs) {
    const rEnd = Math.min(totalRows, r + rs);
    const cEnd = Math.min(totalCols, c + cs);

    for (let rr = r; rr < rEnd; rr++) {
      for (let cc = c; cc < cEnd; cc++) occ[rr][cc] = true;
    }
    if (rs > 1 || cs > 1) {
      merges.push({ s: { r, c }, e: { r: r + rs - 1, c: c + cs - 1 } });
    }
  }
  function nextFreeCol(r, startC) {
    let c = startC;
    while (c < totalCols && occ[r][c]) c++;
    return c;
  }

  // --- 列ヘッダ（上側）を配置：右側(rowHeaderWidth以降)に置く ---
  for (let r = 0; r < colHeaderHeight; r++) {
    const headers = colHeaders[r] || [];
    let c = rowHeaderWidth;

    for (const h of headers) {
      c = nextFreeCol(r, c);
      const cs = h?.hspan ? h.hspan(true) : 1;
      const rs = h?.vspan ? h.vspan(true) : 1;

      aoa[r][c] = { v: toText(h?.value), t: "s", s: colHeaderStyle };
      occupy(r, c, rs, cs);

      c += cs;
    }
  }

  const RED_FONT = { color: { rgb: "FFFF0000" } }; // 赤
  function applyNegativeRed(style, n) {
    if (typeof n === "number" && n < 0) {
      style.font = { ...(style.font || {}), ...RED_FONT };
    }
    return style;
  }

  // --- 行ヘッダ（左側）を配置 + dataRows を配置 ---
  for (let i = 0; i < bodyRows; i++) {
    const sheetRow = colHeaderHeight + i;
    const headers = rowHeaders[i] || [];
    let c = 0;

    for (const h of headers) {
      c = nextFreeCol(sheetRow, c);
      const cs = h?.hspan ? h.hspan(true) : 1;
      const rs = h?.vspan ? h.vspan(true) : 1;

      aoa[sheetRow][c] = { v: toText(h?.value), t: "s", s: rowHeaderStyle };
      occupy(sheetRow, c, rs, cs);

      c += cs;
      if (c >= rowHeaderWidth) break;
    }

    // ★ pivotSpec から numFmt を決める（まず name(ID) で判定。ダメなら保険）
    const rowNumFmt =
      (fmtResolver?.numFmtForRowHeaderRow(rowHeaders[i]) ?? null) ?? defaultNumFmt;

    const dr = dataRows[i] || [];
    for (let j = 0; j < dr.length; j++) {
      const v = dr[j]?.value;
      const col = rowHeaderWidth + j;

      if (v === null || v === undefined || v === "") {
        aoa[sheetRow][col] = { v: "", t: "s", s: valueStyle };
        continue;
      }

      const n = Number(v);
      if (!Number.isFinite(n)) {
        aoa[sheetRow][col] = { v: String(v), t: "s", s: valueStyle };
        continue;
      }

      const s = applyNegativeRed({ ...valueStyle, numFmt: rowNumFmt }, n);

      // xlsx-js-style は `z` が効きやすいので両方入れる（保険）
      aoa[sheetRow][col] = { v: n, t: "n", z: rowNumFmt, s };
    }
  }

  const ws = XLSX.utils.aoa_to_sheet(aoa);
  ws["!merges"] = merges;

  // ===== 罫線（格子） + 列幅オート調整 =====
  const GRID_LINE = { style: "thin", color: { rgb: "FF9DD4E8" } };
  const GRID_BORDER_ALL = { top: GRID_LINE, bottom: GRID_LINE, left: GRID_LINE, right: GRID_LINE };

  function applyGridBorders(ws) {
    const ref = ws["!ref"];
    if (!ref) return;

    const range = XLSX.utils.decode_range(ref);
    for (let r = range.s.r; r <= range.e.r; r++) {
      for (let c = range.s.c; c <= range.e.c; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        let cell = ws[addr];
        if (!cell) cell = ws[addr] = { t: "s", v: "" };
        cell.s = cell.s || {};
        cell.s.border = GRID_BORDER_ALL;
      }
    }
  }

  function calcTextWidth(str) {
    const s = String(str ?? "");
    let w = 0;
    for (const ch of s) w += ch.charCodeAt(0) <= 0x7f ? 1 : 2;
    return w;
  }

  function countTrailingCommas(fmt) {
    const m = String(fmt ?? "").match(/,+$/);
    return m ? m[0].length : 0;
  }

  function displayText(cell) {
    if (!cell) return "";
    const v = cell.v;

    if (cell.t === "n") {
      const n0 = Number(v);
      if (!Number.isFinite(n0)) return "";

      const fmt = cell.z || cell.s?.numFmt;

      if (fmt && String(fmt).includes("%")) {
        const decimals = (String(fmt).match(/0\.([0]+)/)?.[1]?.length) ?? 0;
        return `${(n0 * 100).toFixed(decimals)}%`;
      }

      const k = countTrailingCommas(fmt);
      const n = k > 0 ? n0 / Math.pow(1000, k) : n0;

      if (fmt === "#,##0" || (fmt && String(fmt).startsWith("#,##0"))) {
        return new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 }).format(n);
      }

      return String(n);
    }

    return String(v ?? "");
  }

  function autofitColumns(ws, { minWidth = 8, maxWidth = 30, padding = 2 } = {}) {
    const ref = ws["!ref"];
    if (!ref) return;

    const range = XLSX.utils.decode_range(ref);
    const colCount = range.e.c - range.s.c + 1;
    const widths = Array(colCount).fill(minWidth);

    for (let r = range.s.r; r <= range.e.r; r++) {
      for (let c = range.s.c; c <= range.e.c; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        const cell = ws[addr];
        const text = displayText(cell);
        const w = Math.min(maxWidth, Math.max(minWidth, calcTextWidth(text) + padding));
        widths[c - range.s.c] = Math.max(widths[c - range.s.c], w);
      }
    }

    ws["!cols"] = widths.map((wch) => ({ wch }));
  }

  applyGridBorders(ws);
  autofitColumns(ws, { minWidth: 8, maxWidth: 32, padding: 2 });

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Pivot");
  XLSX.writeFile(wb, fileName);
}
