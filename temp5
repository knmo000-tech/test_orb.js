// src/export/exportOrbAlignedWithMerges.js

/**
 * orb の表示レイアウトに近い形で .xlsx 出力する
 * - rowspan/colspan を occ + nextFreeCol でレイアウト再現
 * - ヘッダは merge せず、結合範囲(rs×cs)へ値を埋めるモードを用意
 * - ヘッダ埋めの「アンカー以外」は薄いグレー文字にする
 * - numFmt は pivotSpec から決定（Web/Excel を単一定義化）
 *
 * オプション:
 * - includeColHeaders: 上側ヘッダを出す（デフォルト true）
 * - mergeColHeaders:   上側ヘッダを merge する（デフォルト false）
 * - mergeRowHeaders:   左側ヘッダを merge する（デフォルト false）
 * - faintHeaderFill:   埋めセル(アンカー以外)の文字を薄くする（デフォルト true）
 * - defaultNumFmt:     マッチしない場合の既定（デフォルト "General"）
 */
function exportOrbAlignedWithMerges(
  pgridwidget,
  fileName = "pivot_aligned.xlsx",
  pivotSpec = null,
  opts = {}
) {
  const XLSX = opts.XLSX ?? globalThis.XLSX;
  if (!XLSX) throw new Error("XLSX(xlsx-js-style) が見つかりません。globalThis.XLSX を確認してください。");

  const includeColHeaders = opts.includeColHeaders ?? true;
  const mergeColHeaders = opts.mergeColHeaders ?? false;
  const mergeRowHeaders = opts.mergeRowHeaders ?? false;
  const faintHeaderFill = opts.faintHeaderFill ?? true;
  const defaultNumFmt = opts.defaultNumFmt ?? "General";

  const rowHeaders = pgridwidget?.rows?.headers || [];
  const dataRows = pgridwidget?.dataRows || [];
  const colHeaders = pgridwidget?.columns?.headers || pgridwidget?.cols?.headers || [];

  const bodyRows = Math.max(rowHeaders.length, dataRows.length);
  const colHeaderHeight = includeColHeaders ? colHeaders.length : 0;

  // data列数（右側の値セル数）
  const dataCols = dataRows.reduce((m, r) => Math.max(m, (r || []).length), 0);

  // row header 幅（左側のヘッダ列数）は「hspanの合計の最大」で決める
  const rowHeaderWidth = rowHeaders.reduce((m, r) => {
    const w = (r || []).reduce((s, h) => s + (h?.hspan ? h.hspan(true) : 1), 0);
    return Math.max(m, w);
  }, 0);

  const totalRows = colHeaderHeight + bodyRows;
  const totalCols = rowHeaderWidth + dataCols;

  // ===== PivotSpec 由来の numFmt 引き当て（caption依存を極小化） =====
  const spec = pivotSpec ?? globalThis.pivotSpec ?? null;

  function toText(v) {
    if (v == null) return "";
    if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") return String(v);
    if (typeof v === "object") {
      if ("caption" in v && v.caption != null) return String(v.caption);
      if ("name" in v && v.name != null) return String(v.name);
      if ("value" in v && v.value != null) return String(v.value);
    }
    try {
      return JSON.stringify(v);
    } catch {
      return String(v);
    }
  }

  const fmtResolver = (() => {
    if (!spec?.fields) return null;

    const norm = (s) => String(s ?? "").trim();

    // name(ID) -> numFmt
    const byName = new Map();
    // caption -> name(ID)（orbがIDを返してくれない時の保険）
    const captionToName = new Map();

    for (const f of spec.fields) {
      if (!f?.dataSettings) continue; // measureだけ対象
      const id = String(f.name);
      const fmt = f?.excel?.numFmt ?? null;
      byName.set(id, fmt);
      captionToName.set(norm(f.caption), id);
    }

    function extractIdFromHeaderValue(v) {
      if (v == null) return null;

      if (typeof v === "number") return String(v);
      if (typeof v === "string") {
        const s = v.trim();
        if (s && /^-?\d+(\.\d+)?$/.test(s)) return String(Number(s));
        if (captionToName.has(norm(s))) return captionToName.get(norm(s));
        return null;
      }

      if (typeof v === "object") {
        const candidates = [
          v.name, v.field, v.fieldName, v.fieldId,
          v.datafield, v.dataField, v.measure, v.measureId,
          v.value,
        ];

        for (const c of candidates) {
          if (typeof c === "number") return String(c);
          if (typeof c === "string") {
            const s = c.trim();
            if (s && /^-?\d+(\.\d+)?$/.test(s)) return String(Number(s));
            if (captionToName.has(norm(s))) return captionToName.get(norm(s));
          }
        }

        if (v.caption != null) {
          const key = norm(v.caption);
          if (captionToName.has(key)) return captionToName.get(key);
        }
      }

      return null;
    }

    function numFmtForRowHeaderRow(rhRow) {
      if (!Array.isArray(rhRow)) return null;

      // 1) ID(name) 優先
      for (const h of rhRow) {
        const id = extractIdFromHeaderValue(h?.value);
        if (!id) continue;
        if (byName.has(id)) return byName.get(id);
      }

      // 2) caption保険
      for (const h of rhRow) {
        const t = norm(toText(h?.value));
        const id = captionToName.get(t);
        if (id && byName.has(id)) return byName.get(id);
      }

      return null;
    }

    return { numFmtForRowHeaderRow };
  })();

  // --- theme ---
  const BLUE_HEADER_FILL = "FFEAF8FF";
  const BLUE_BORDER = "FF9DD4E8";
  const GRID_BORDER = { style: "thin", color: { rgb: BLUE_BORDER } };

  // ★埋めセル(アンカー以外)の薄いグレー
  const FAINT_TEXT_RGB = "FFBFBFBF";

  function faintStyle(base) {
    if (!faintHeaderFill) return base;
    return {
      ...base,
      font: { ...(base.font || {}), color: { rgb: FAINT_TEXT_RGB } },
    };
  }

  const colHeaderStyle = {
    font: { bold: true },
    alignment: { vertical: "center", horizontal: "center", wrapText: true },
    fill: { patternType: "solid", fgColor: { rgb: BLUE_HEADER_FILL } },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  const rowHeaderStyle = {
    font: { bold: true },
    alignment: { vertical: "center", horizontal: "left", wrapText: true },
    fill: { patternType: "solid", fgColor: { rgb: BLUE_HEADER_FILL } },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  const valueStyle = {
    alignment: { vertical: "center", horizontal: "right" },
    border: { top: GRID_BORDER, bottom: GRID_BORDER, left: GRID_BORDER, right: GRID_BORDER },
  };

  // grid/occ/merges
  const aoa = Array.from({ length: totalRows }, () => Array.from({ length: totalCols }, () => ""));
  const occ = Array.from({ length: totalRows }, () => Array.from({ length: totalCols }, () => false));
  const merges = [];

  function occupy(r, c, rs, cs, doMerge = true) {
    const rEnd = Math.min(totalRows, r + rs);
    const cEnd = Math.min(totalCols, c + cs);
    for (let rr = r; rr < rEnd; rr++) for (let cc = c; cc < cEnd; cc++) occ[rr][cc] = true;

    if (doMerge && (rs > 1 || cs > 1)) {
      merges.push({ s: { r, c }, e: { r: r + rs - 1, c: c + cs - 1 } });
    }
  }

  function nextFreeCol(r, startC) {
    let c = startC;
    while (c < totalCols && occ[r][c]) c++;
    return c;
  }

  // ===== 上側ヘッダ（colHeaders） =====
  if (includeColHeaders) {
    for (let r = 0; r < colHeaderHeight; r++) {
      const headers = colHeaders[r] || [];
      let c = rowHeaderWidth;

      for (const h of headers) {
        c = nextFreeCol(r, c);
        const cs = h?.hspan ? h.hspan(true) : 1;
        const rs = h?.vspan ? h.vspan(true) : 1;
        const text = toText(h?.value);

        if (mergeColHeaders) {
          aoa[r][c] = { v: text, t: "s", s: colHeaderStyle };
          occupy(r, c, rs, cs, true);
        } else {
          // ★結合しない：範囲に埋め、アンカー以外は薄グレー
          for (let rr = r; rr < r + rs; rr++) {
            for (let cc = c; cc < c + cs; cc++) {
              if (rr < 0 || rr >= totalRows || cc < 0 || cc >= totalCols) continue;

              const isAnchor = (cc === c); // 上側は「結合範囲の1番左」をアンカー扱い
              aoa[rr][cc] = { v: text, t: "s", s: isAnchor ? colHeaderStyle : faintStyle(colHeaderStyle) };
            }
          }
          occupy(r, c, rs, cs, false);
        }

        c += cs;
      }
    }
  }

  // ===== 左側ヘッダ（rowHeaders） + 値（dataRows） =====
  const RED_FONT = { color: { rgb: "FFFF0000" } };
  function applyNegativeRed(style, n) {
    if (typeof n === "number" && n < 0) style.font = { ...(style.font || {}), ...RED_FONT };
    return style;
  }

  for (let i = 0; i < bodyRows; i++) {
    const sheetRow = colHeaderHeight + i;
    const headers = rowHeaders[i] || [];
    let c = 0;

    for (const h of headers) {
      c = nextFreeCol(sheetRow, c);
      const cs = h?.hspan ? h.hspan(true) : 1;
      const rs = h?.vspan ? h.vspan(true) : 1;
      const text = toText(h?.value);

      if (mergeRowHeaders) {
        aoa[sheetRow][c] = { v: text, t: "s", s: rowHeaderStyle };
        occupy(sheetRow, c, rs, cs, true);
      } else {
        // ★結合しない：範囲に埋め、アンカー以外は薄グレー
        for (let rr = sheetRow; rr < sheetRow + rs; rr++) {
          for (let cc = c; cc < c + cs; cc++) {
            if (rr < 0 || rr >= totalRows || cc < 0 || cc >= totalCols) continue;

            const isAnchor = (rr === sheetRow); // 左側は「結合範囲の1番上」をアンカー扱い
            aoa[rr][cc] = { v: text, t: "s", s: isAnchor ? rowHeaderStyle : faintStyle(rowHeaderStyle) };
          }
        }
        occupy(sheetRow, c, rs, cs, false);
      }

      c += cs;
      if (c >= rowHeaderWidth) break;
    }

    const rowNumFmt = (fmtResolver?.numFmtForRowHeaderRow(rowHeaders[i]) ?? null) ?? defaultNumFmt;

    const dr = dataRows[i] || [];
    for (let j = 0; j < dr.length; j++) {
      const v = dr[j]?.value;
      const col = rowHeaderWidth + j;

      if (v === null || v === undefined || v === "") {
        aoa[sheetRow][col] = { v: "", t: "s", s: valueStyle };
        continue;
      }

      const n = Number(v);
      if (!Number.isFinite(n)) {
        aoa[sheetRow][col] = { v: String(v), t: "s", s: valueStyle };
        continue;
      }

      const s = applyNegativeRed({ ...valueStyle, numFmt: rowNumFmt }, n);
      aoa[sheetRow][col] = { v: n, t: "n", z: rowNumFmt, s };
    }
  }

  const ws = XLSX.utils.aoa_to_sheet(aoa);
  ws["!merges"] = merges;

  // ===== 罫線（格子） + 列幅オート調整 =====
  const GRID_LINE = { style: "thin", color: { rgb: "FF9DD4E8" } };
  const GRID_BORDER_ALL = { top: GRID_LINE, bottom: GRID_LINE, left: GRID_LINE, right: GRID_LINE };

  function applyGridBorders(ws) {
    const ref = ws["!ref"];
    if (!ref) return;

    const range = XLSX.utils.decode_range(ref);
    for (let r = range.s.r; r <= range.e.r; r++) {
      for (let c = range.s.c; c <= range.e.c; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        let cell = ws[addr];
        if (!cell) cell = ws[addr] = { t: "s", v: "" };
        cell.s = cell.s || {};
        cell.s.border = GRID_BORDER_ALL;
      }
    }
  }

  function calcTextWidth(str) {
    const s = String(str ?? "");
    let w = 0;
    for (const ch of s) w += ch.charCodeAt(0) <= 0x7f ? 1 : 2;
    return w;
  }

  function countTrailingCommas(fmt) {
    const m = String(fmt ?? "").match(/,+$/);
    return m ? m[0].length : 0;
  }

  function displayText(cell) {
    if (!cell) return "";
    const v = cell.v;

    if (cell.t === "n") {
      const n0 = Number(v);
      if (!Number.isFinite(n0)) return "";

      const fmt = cell.z || cell.s?.numFmt;

      if (fmt && String(fmt).includes("%")) {
        const decimals = (String(fmt).match(/0\.([0]+)/)?.[1]?.length) ?? 0;
        return `${(n0 * 100).toFixed(decimals)}%`;
      }

      const k = countTrailingCommas(fmt);
      const n = k > 0 ? n0 / Math.pow(1000, k) : n0;

      if (fmt === "#,##0" || (fmt && String(fmt).startsWith("#,##0"))) {
        return new Intl.NumberFormat("en-US", { maximumFractionDigits: 0 }).format(n);
      }

      return String(n);
    }

    return String(v ?? "");
  }

  function autofitColumns(ws, { minWidth = 8, maxWidth = 30, padding = 2 } = {}) {
    const ref = ws["!ref"];
    if (!ref) return;

    const range = XLSX.utils.decode_range(ref);
    const colCount = range.e.c - range.s.c + 1;
    const widths = Array(colCount).fill(minWidth);

    for (let r = range.s.r; r <= range.e.r; r++) {
      for (let c = range.s.c; c <= range.e.c; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        const cell = ws[addr];
        const text = displayText(cell);
        const w = Math.min(maxWidth, Math.max(minWidth, calcTextWidth(text) + padding));
        widths[c - range.s.c] = Math.max(widths[c - range.s.c], w);
      }
    }

    ws["!cols"] = widths.map((wch) => ({ wch }));
  }

  applyGridBorders(ws);
  autofitColumns(ws, { minWidth: 8, maxWidth: 32, padding: 2 });

  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Pivot");
  XLSX.writeFile(wb, fileName);
}
